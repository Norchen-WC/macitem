var options = { argv: process.argv, env: process.env }
  , re = /[a-z]+[a-z0-9_]*/
  , sections = []

var blacklist = [
  'apply',
  'arguments',
  'bind',
  'call',
  'caller',
  'constructor',
  'length',
  'name'
]

function setting(section, option, value, type) {
  if (arguments.length === 1 && typeof section === 'object')
    return config(section)

  if (typeof section !== 'string' || !section.match(re) || blacklist.indexOf(section) >= 0)
    throw new Error('Invalid section')

  if (typeof option !== 'string' || !option.match(re))
    throw new Error('Invalid option')

  if (arguments.length == 3)
    type = typeof value

  if (!setting.hasOwnProperty(section)) {
    setting[section] = {}
    sections.push(section)
  }

  if (!setting[section].hasOwnProperty(option)) {
    var argvName = '--' + [section, option].join('-').replace(/_/g, '-')
      , skipNext = false
    options.argv.forEach(function(a, i) {
      if (skipNext) {
        skipNext = false
        return
      }
      var startsWith = a.indexOf(argvName + '=') >= 0
      if (a === argvName || startsWith) {
        switch (type) {
          case 'bool':
          case 'boolean':
          case Boolean:
            if (startsWith) {
              setting[section][option] = a.slice(argvName.length + 1)
            } else {
              setting[section][option] = !value
            }
            break
          default:
            if (startsWith) {
              setting[section][option] = a.slice(argvName.length + 1)
            } else {
              setting[section][option] = options.argv[i+1]
              skipNext = true
            }
            break
        }
      }
    })
  }

  if (!setting[section].hasOwnProperty(option)) {
    var envName = [section, option].join('_').toUpperCase()
    // can't call hasOwnProperty on options.env directly
    setting[section][option] = Object.prototype.hasOwnProperty.call(options.env, envName) ?
      options.env[envName] : value
  }

  value = setting[section][option]

  switch (type) {
    case 'bool':
    case 'boolean':
    case Boolean:
      setting[section][option] = ['1', 'on', 'true', 'yes'].indexOf(value.toString()) >= 0
      break
    case 'int':
    case 'integer':
      setting[section][option] = parseInt(value, 10)
      break
    case 'num':
    case 'number':
    case Number:
      setting[section][option] = parseFloat(value)
      break
    case 'str':
    case 'string':
    case String:
      setting[section][option] = '' + value
      break
    case undefined:
      break
    default:
      throw new Error('Unknown type: ' + type)
  }

  return setting[section][option]
}

function config(args) {
  if (args.hasOwnProperty('argv')) {
    switch (typeof args.argv) {
      case 'boolean':
        options.argv = args.argv ? process.argv : []
        break
      case 'object':
        if (!Array.isArray(args.argv))
          throw new Error('Invalid args')
        options.argv = args.argv
        break
      default:
        throw new Error('Invalid argv')
    }
  }

  if (args.hasOwnProperty('env')) {
    switch (typeof args.env) {
      case 'boolean':
        options.env = args.env ? process.env : {}
        break
      case 'object':
        options.env = args.env
        break
      default:
        throw new Error('Invalid env')
    }
  }

  if (args.reset === true) {
    while (sections.length) {
      delete setting[sections.pop()]
    }
  }
}

module.exports = setting
